# Story 3.1: Smart Reminder System

## Status

Draft

## Story

**As a** user who wants to maintain consistent journaling habits,
**I want** to receive intelligent, adaptive reminders based on my usage patterns and relationship needs,
**so that** I can stay engaged with journaling and maintain relationship health tracking without feeling overwhelmed by notifications.

## Acceptance Criteria

1. System adapts reminder timing based on user's historical journaling patterns
2. Contextual prompts are provided for specific relationships that need attention
3. Notification preferences and timing controls are fully customizable by the user
4. Reminders respect user's "do not disturb" preferences and timezone
5. Different reminder types are available (gentle nudges, relationship-focused, health score alerts)
6. Users can easily enable/disable or modify reminder settings
7. Reminder system integrates with browser notifications and user preferences
8. Analytics track reminder effectiveness and user engagement
9. Reminders are personalized based on relationship health trends
10. System gracefully handles offline/online state changes

## Tasks / Subtasks

### Database Schema & Reminder Configuration

- [ ] **SRS-001**: Design and implement notification preferences schema (AC: 3, 4, 6)
  - [ ] Extend users table with notification preferences
  - [ ] Create reminder patterns table for user-specific scheduling
  - [ ] Add timezone support for proper timing
  - [ ] Implement "do not disturb" time window settings

- [ ] **SRS-002**: Create reminder tracking and analytics schema (AC: 8)
  - [ ] Design reminder_logs table for tracking delivery and engagement
  - [ ] Create reminder_analytics table for pattern analysis
  - [ ] Add fields for tracking click-through rates and dismissal patterns
  - [ ] Implement data retention policies for analytics data

### Adaptive Scheduling Engine

- [ ] **SRS-003**: Implement pattern recognition for user behavior (AC: 1)
  - [ ] Create algorithm to analyze user's journaling frequency patterns
  - [ ] Build optimal timing calculator based on historical data
  - [ ] Implement adaptive learning system for reminder effectiveness
  - [ ] Add fallback scheduling for new users without pattern data

- [ ] **SRS-004**: Build contextual relationship analysis (AC: 2, 9)
  - [ ] Create system to identify relationships needing attention
  - [ ] Implement health score decline detection for urgent reminders
  - [ ] Build relationship-specific reminder content generation
  - [ ] Add logic for relationship interaction recency analysis

### Notification System Backend

- [ ] **SRS-005**: Implement Convex scheduled functions for reminder delivery (AC: 1, 2, 4)
  - [ ] Create cron functions for daily reminder processing
  - [ ] Build reminder queue management system
  - [ ] Implement timezone-aware scheduling logic
  - [ ] Add retry mechanisms for failed notifications

- [ ] **SRS-006**: Create notification content generation system (AC: 2, 5, 9)
  - [ ] Build template system for different reminder types
  - [ ] Implement personalization engine using relationship data
  - [ ] Create dynamic content generation based on health scores
  - [ ] Add A/B testing framework for reminder effectiveness

### Frontend Notification Components

- [ ] **SRS-007**: Build notification preferences UI (AC: 3, 6)
  - [ ] Create notification settings page in user profile
  - [ ] Build timing controls with visual scheduling interface  
  - [ ] Implement toggle controls for different reminder types
  - [ ] Add timezone selector and "do not disturb" time windows

- [ ] **SRS-008**: Implement browser notification integration (AC: 7)
  - [ ] Build browser notification permission handling
  - [ ] Create notification click handling and routing
  - [ ] Implement notification badge and visual indicators
  - [ ] Add graceful fallback for browsers without notification support

### Reminder Types and Content

- [ ] **SRS-009**: Create gentle nudge reminders (AC: 5)
  - [ ] Design non-intrusive reminder content for regular journaling
  - [ ] Implement progressive reminder intensity based on user response
  - [ ] Create inspiring and motivational reminder messages
  - [ ] Add randomization to prevent notification fatigue

- [ ] **SRS-010**: Build relationship-focused reminders (AC: 2, 9)
  - [ ] Create reminders for specific relationships needing attention
  - [ ] Implement context-aware prompts based on relationship type
  - [ ] Build reminders triggered by health score changes
  - [ ] Add celebration reminders for relationship improvements

### System Integration & Performance

- [ ] **SRS-011**: Implement offline/online state management (AC: 10)
  - [ ] Build notification queue for offline users
  - [ ] Create sync mechanism for missed notifications
  - [ ] Implement service worker for offline notification handling
  - [ ] Add notification history for offline periods

- [ ] **SRS-012**: Add analytics and effectiveness tracking (AC: 8)
  - [ ] Implement reminder delivery tracking
  - [ ] Build engagement metrics collection
  - [ ] Create dashboard for reminder effectiveness analysis
  - [ ] Add A/B testing for reminder optimization

### Testing

- [ ] **SRS-013**: Write comprehensive notification system tests (AC: All)
  - [ ] Test scheduled function execution and timing
  - [ ] Test browser notification integration across different browsers
  - [ ] Test adaptive learning algorithms with mock data
  - [ ] Test timezone handling and "do not disturb" functionality
  - [ ] Test notification preferences UI and settings persistence

## Dev Notes

### Previous Story Insights

**Source: Story 2.2 Completion**

- Dashboard system is fully operational with real-time health score updates
- User preferences system exists with notification toggle in user schema
- Health score calculation and trending data are available for reminder triggers  
- All Convex infrastructure is ready for scheduled functions and real-time updates
- TypeScript ecosystem is mature with comprehensive testing patterns established

### Data Models and Schema

**Source: [docs/architecture/source-tree.md#backend-structure-convex]**

**Existing User Schema Enhancement** (extend existing schema):

```typescript
// Extend users table preferences (already in convex/schema.ts)
preferences: v.optional(
  v.object({
    theme: v.optional(v.union(v.literal('light'), v.literal('dark'))),
    notifications: v.optional(v.boolean()), // Already exists - base toggle
    // NEW FIELDS TO ADD:
    reminderSettings: v.optional(v.object({
      enabled: v.boolean(),
      frequency: v.union(v.literal('daily'), v.literal('every2days'), v.literal('weekly')),
      preferredTime: v.string(), // "HH:MM" format
      timezone: v.string(), // IANA timezone
      doNotDisturbStart: v.string(), // "HH:MM"  
      doNotDisturbEnd: v.string(), // "HH:MM"
      reminderTypes: v.object({
        gentleNudge: v.boolean(),
        relationshipFocus: v.boolean(),
        healthScoreAlerts: v.boolean(),
      }),
    })),
    language: v.optional(v.string()),
    dataSharing: v.optional(v.boolean()),
    analyticsOptIn: v.optional(v.boolean()),
    marketingOptIn: v.optional(v.boolean()),
    searchIndexing: v.optional(v.boolean()),
    dataRetention: v.optional(v.union(v.literal('1year'), v.literal('3years'), v.literal('indefinite'))),
  })
),
```

**New Tables to Create**:

```typescript
// NEW TABLE: Reminder delivery tracking
reminderLogs: defineTable({
  userId: v.id('users'),
  reminderType: v.union(v.literal('gentle_nudge'), v.literal('relationship_focus'), v.literal('health_alert')),
  targetRelationshipId: v.optional(v.id('relationships')), // For relationship-specific reminders
  scheduledTime: v.number(),
  deliveredTime: v.optional(v.number()),
  status: v.union(v.literal('scheduled'), v.literal('delivered'), v.literal('clicked'), v.literal('dismissed'), v.literal('failed')),
  content: v.string(), // The actual reminder message
  metadata: v.object({
    triggerReason: v.string(), // Why this reminder was sent
    healthScoreAtTime: v.optional(v.number()),
    daysSinceLastEntry: v.optional(v.number()),
  }),
  createdAt: v.number(),
  updatedAt: v.number(),
})
.index('by_user', ['userId'])
.index('by_user_and_status', ['userId', 'status'])
.index('by_scheduled_time', ['scheduledTime']),

// NEW TABLE: User pattern analysis  
userPatterns: defineTable({
  userId: v.id('users'),
  patternType: v.union(v.literal('journaling_frequency'), v.literal('optimal_timing'), v.literal('engagement_response')),
  analysisData: v.object({
    averageDaysBetweenEntries: v.optional(v.number()),
    mostActiveHours: v.optional(v.array(v.number())), // Hours of day (0-23)
    bestResponseTimes: v.optional(v.array(v.string())), // "HH:MM" format
    engagementScore: v.optional(v.number()), // 0-100 based on reminder responses
    lastCalculated: v.number(),
  }),
  confidenceLevel: v.number(), // 0-1 based on data availability
  createdAt: v.number(),
  updatedAt: v.number(),
})
.index('by_user', ['userId'])
.index('by_pattern_type', ['patternType'])
.index('by_user_and_type', ['userId', 'patternType']),
```

### Component Specifications

**Source: [docs/architecture/source-tree.md#component-organization]**

**Notification Components Structure**:

```
src/components/features/notifications/
├── reminder-settings.tsx           # Main settings panel for reminders
├── notification-preferences.tsx    # Detailed preference controls
├── timing-controls.tsx             # Time picker and schedule interface
├── reminder-type-toggles.tsx       # Toggle switches for reminder types
├── notification-history.tsx        # History of sent reminders
└── __tests__/
    ├── reminder-settings.test.tsx
    ├── notification-preferences.test.tsx
    ├── timing-controls.test.tsx
    └── reminder-type-toggles.test.tsx
```

**Profile Settings Integration**:

```
src/app/profile/settings/
└── notifications/
    └── page.tsx                    # Notifications settings page
```

### File Locations and Structure

**Source: [docs/architecture/source-tree.md#app-router-structure]**

**Backend Functions** (Convex):

```
convex/
├── notifications.ts               # Core notification functions (NEW)
├── crons.ts                       # Scheduled reminder processing (EXTEND)
├── userPatterns.ts                # User behavior analysis (NEW)
└── utils/
    ├── reminder_logic.ts          # Reminder scheduling algorithms (NEW)
    ├── notification_content.ts    # Message generation utilities (NEW)
    └── pattern_analysis.ts        # User pattern analysis utilities (NEW)
```

**Frontend Structure**:

```
src/app/profile/settings/notifications/
├── page.tsx                       # Notification settings page (NEW)
└── __tests__/
    └── notifications-settings.test.tsx (NEW)

src/hooks/notifications/
├── use-notification-preferences.ts # Notification preferences hook (NEW)
├── use-reminder-analytics.ts      # Reminder tracking hook (NEW)  
└── use-browser-notifications.ts   # Browser API integration hook (NEW)
```

### Notification System Architecture

**Source: [docs/architecture/tech-stack.md#third-party-integrations]**

**Browser Notification Integration**:

Using native Web Notifications API with progressive enhancement:

```typescript
// Browser notification capability detection
const browserSupportsNotifications = 'Notification' in window
const notificationPermission = await Notification.requestPermission()

// Fallback to in-app notifications for unsupported browsers
if (!browserSupportsNotifications || notificationPermission === 'denied') {
  // Use in-app notification system
}
```

**Scheduled Function Pattern**:

```typescript
// Convex cron pattern for reminder processing
export const processScheduledReminders = internalMutation({
  handler: async (ctx) => {
    const now = Date.now()
    const pendingReminders = await ctx.db
      .query('reminderLogs')
      .withIndex('by_scheduled_time')
      .filter(q => q.and(
        q.lte(q.field('scheduledTime'), now),
        q.eq(q.field('status'), 'scheduled')
      ))
      .collect()

    // Process each reminder...
  },
})
```

### Adaptive Learning Algorithm

**Source: [docs/algorithm-ai/core-algorithm-methodology.md]**

**User Pattern Analysis**:

The system analyzes user behavior to optimize reminder timing:

1. **Frequency Analysis**: Calculate average days between journal entries
2. **Timing Optimization**: Identify most responsive hours based on historical engagement  
3. **Relationship Focus**: Determine which relationships need attention based on health trends
4. **Engagement Scoring**: Track reminder effectiveness and adjust algorithms

**Calculation Approach**:

```typescript
interface UserEngagementPattern {
  averageDaysBetweenEntries: number
  mostActiveHours: number[] // Hours of day (0-23)
  bestResponseTimes: string[] // "HH:MM" format  
  engagementScore: number // 0-100 based on reminder responses
  relationshipAttentionNeeded: RelationshipId[] // IDs needing focus
}
```

### Technical Constraints and Requirements

**Source: [docs/architecture/coding-standards.md#react-nextjs-standards]**

**Notification Permission Handling**:

- Request permissions gracefully with clear user benefit explanation
- Provide fallback experiences for denied permissions  
- Follow progressive enhancement principles
- Handle browser compatibility differences gracefully

**Performance Requirements**:

- Reminder processing must complete within 30 seconds
- Browser notifications should appear within 5 seconds of trigger
- Settings changes should persist immediately (< 1 second)
- Pattern analysis should run as background job without blocking UI

**Privacy Considerations**:

- Users must explicitly opt-in to browser notifications
- Notification content should not reveal sensitive journal details in notification preview
- All reminder preferences must be user-controllable
- Analytics data must respect user privacy preferences

### Scheduled Functions Configuration  

**Source: [docs/architecture/tech-stack.md#api-architecture]**

**Convex Cron Setup**:

```typescript
// convex/crons.ts - Scheduled function configuration
import { cronJobs } from 'convex/server'
import { internal } from './_generated/api'

const crons = cronJobs()

// Process daily reminders
crons.interval(
  'process-daily-reminders',
  { minutes: 30 }, // Check every 30 minutes
  internal.notifications.processScheduledReminders,
)

// Update user patterns weekly  
crons.weekly(
  'update-user-patterns', 
  { dayOfWeek: 'sunday', hourUTC: 2, minuteUTC: 0 },
  internal.userPatterns.recalculateUserPatterns,
)

export default crons
```

### Browser Integration Patterns

**Source: [docs/architecture/coding-standards.md#react-nextjs-standards]**

**Service Worker for Offline Notifications** (Future enhancement):

```typescript
// public/sw.js - Service worker for offline notification handling
self.addEventListener('notificationclick', event => {
  event.notification.close()
  
  // Navigate to journal entry or dashboard
  event.waitUntil(
    clients.openWindow('/dashboard')
  )
})
```

**React Hook Pattern for Notifications**:

```typescript
// Custom hook for browser notification integration
export function useBrowserNotifications() {
  const [permission, setPermission] = useState<NotificationPermission>('default')
  const [isSupported, setIsSupported] = useState(false)

  const requestPermission = async () => {
    if ('Notification' in window) {
      const result = await Notification.requestPermission()
      setPermission(result)
      return result
    }
    return 'denied'
  }

  // Additional notification management logic...
}
```

## Testing

**Source: [docs/architecture/coding-standards.md#testing-standards]**

### Test File Location

- Component tests: `src/components/features/notifications/__tests__/`
- Page tests: `src/app/profile/settings/notifications/__tests__/`
- Hook tests: `src/hooks/notifications/__tests__/`
- Convex function tests: `convex/__tests__/notifications.test.ts`
- Integration tests: `tests/integration/notifications/__tests__/`

### Testing Framework Requirements

- **Jest 30.0.4**: Primary testing framework with TypeScript support
- **React Testing Library**: Component testing with user behavior focus
- **@testing-library/jest-dom**: Enhanced DOM assertions for notification UI
- **Mock Service Worker (MSW)**: For mocking browser notification APIs

### Specific Testing Requirements for Smart Reminders

- Mock browser Notification API and permission states
- Test scheduled function execution with time manipulation
- Test user pattern analysis with various data scenarios
- Test timezone handling across different user locations
- Test "do not disturb" functionality with edge cases
- Test notification click handling and routing
- Test offline/online state changes and notification queuing

### Testing Standards Pattern

```typescript
// Notification System Testing Pattern
describe('ReminderSettings', () => {
  const mockUserPreferences = {
    reminderSettings: {
      enabled: true,
      frequency: 'daily' as const,
      preferredTime: '09:00',
      timezone: 'America/New_York',
      doNotDisturbStart: '22:00',
      doNotDisturbEnd: '07:00',
      reminderTypes: {
        gentleNudge: true,
        relationshipFocus: true,
        healthScoreAlerts: false,
      },
    },
  }

  beforeEach(() => {
    // Mock browser notification API
    Object.defineProperty(window, 'Notification', {
      value: {
        permission: 'granted',
        requestPermission: jest.fn().mockResolvedValue('granted'),
      },
      writable: true,
    })
  })

  it('should display reminder preferences correctly', () => {
    render(<ReminderSettings preferences={mockUserPreferences} />)

    expect(screen.getByRole('switch', { name: /enable reminders/i })).toBeChecked()
    expect(screen.getByDisplayValue('09:00')).toBeInTheDocument()
    expect(screen.getByDisplayValue('America/New_York')).toBeInTheDocument()
  })

  it('should handle timezone changes correctly', async () => {
    const user = userEvent.setup()
    const mockOnUpdate = jest.fn()
    
    render(<ReminderSettings preferences={mockUserPreferences} onUpdate={mockOnUpdate} />)

    await user.selectOptions(screen.getByRole('combobox', { name: /timezone/i }), 'Europe/London')

    expect(mockOnUpdate).toHaveBeenCalledWith({
      ...mockUserPreferences.reminderSettings,
      timezone: 'Europe/London',
    })
  })

  it('should respect do not disturb settings', () => {
    const currentTime = '23:30' // Within do not disturb hours
    
    const shouldSendReminder = checkDoNotDisturbTime(
      currentTime,
      mockUserPreferences.reminderSettings.doNotDisturbStart,
      mockUserPreferences.reminderSettings.doNotDisturbEnd
    )

    expect(shouldSendReminder).toBe(false)
  })
})
```

## Change Log

| Date       | Version | Description                                     | Author       |
| ---------- | ------- | ----------------------------------------------- | ------------ |
| 2025-07-22 | 1.0     | Initial story creation for Smart Reminder System | Scrum Master |

## Dev Agent Record

### Agent Model Used

_To be populated by development agent_

### Debug Log References  

_To be populated by development agent_

### Completion Notes List

_To be populated by development agent_

### File List

_To be populated by development agent_

## QA Results

_To be populated by QA Agent after story completion_